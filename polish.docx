#include<stdio.h>
#include<stdlib.h>
#include<conio.h>
#include<locale.h>

struct st             // Описание структуры(элемента стека)
{
	char c;
	struct st *next;
};

struct st *push(struct st *, char); // занесение на вершину стека
char pop(struct st **);      // чтение с вершины стека
int PRIOR(char);      // возвращает приоритет операции

int main()
{
	setlocale(LC_ALL, "Russian");
	struct st *OPR = NULL;       // Стек операций пуст
	char in[80], out[80];    // входная и выходная строки
	int k, point;
	do
	{
		puts("Введите выражение(в конце '='):");
		rewind(stdin);
		gets(in);                             // Ввод арифметического выражения
		k = point = 0;
		while (in[k] != '\0' && in[k] != '=') // пока не дойдем до '='
		{
			if (in[k] == ')')                 // Если очередной символ - ')'
			{
				while ((OPR->c) != '(')       // то выталкиваем из стека в
					out[point++] = pop(&OPR); // выходную строку
											  // все знаки операций до открывающей скобки
				pop(&OPR);                    // Удаляем из стека открывающую скобку
			}
			if (in[k] >= 'a' && in[k] <= 'z') // Если символ - буква ,то
				out[point++] = in[k];         // заносим её в выходную строку
			if (in[k] == '(')                 // Если очередной символ - '(' ,то
				OPR = push(OPR, '(');         // записываем её в стек
			if (in[k] == '+' || in[k] == '-' || in[k] == '/' || in[k] == '*' || in[k] == '^')
			{                                 // Если следующий символ - знак операции, то:
				while ((OPR != NULL) && (PRIOR(OPR->c) >= PRIOR(in[k])) &&                    //не выполняется для сравнения (
					((in[k] != '^') || ((in[k] == '^') && (OPR->c != '^'))))
					out[point++] = pop(&OPR); // переписываем в выходную строку все
											  // находящиеся в стеке операции с большим или 
											  // равным приоритетом
				OPR = push(OPR, in[k]);       // записываем в стек поступившую операцию
			}
			k++;                              // Переход к следующему символу входной строки
		}
		while (OPR != NULL)        // после рассмотрения всего выражения
			out[point++] = pop(&OPR); // переписываем операции из
		out[point] = '\0';            // стека в выходную строку
		printf("\n%s\n", out);        // и печатаем её
		rewind(stdin);
		puts("\nПовторить(y/n)?");
	} while (getchar() != 'n');
	return 0;
}
// push записывает в стек символ a, возвращает
// указатель на новую вершину стека
struct st *push(struct st *head, char a)
{                       // head - указатель на вершину стека
	struct st *PTR;
	if (!(PTR = (struct st*)malloc(sizeof(struct st))))
	{
		puts("Нет свободной памяти"); exit(-1);
	}
	PTR->c = a;         // операция записи на вершину стека
	PTR->next = head;   // указатель на предыдущую вершину
	return PTR;         // PTR -новая вершина стека
}

// pop   удаляет символ с вершины стека. Возвращает
// удаляемый символ. Изменяет указатель на вершину стека
char pop(struct st **head) // либо значение, либо \0
{
    struct st *PTR;
	char a;
	if (!(*head)) return '\0'; // Если стек пуст, возвращаем '\0'
	PTR = *head;               // в PTR - адрес вершины стека
	a = PTR->c;                // чтение символа с вершины стека
	*head = PTR->next;         // указатель на новую вершину стека
	free(PTR);                 // Освобождение памяти (предыдущая вершина стека)
	return a;                  // Возврат символа считанного с вершины стека
}

// Функция PRIOR возвращает приоритет арифм. операции
int PRIOR(char a)
{
	switch (a)
	{
	case '^':return 4;
	case '*':case '/':return 3;
	case '-':case '+':return 2;
	case '(':return 1;
	} return 0;
}
