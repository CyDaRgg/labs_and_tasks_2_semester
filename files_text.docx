#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <io.h>
#include <locale.h>
// --------------------------------------------  ТЕКСТОВЫЙ ФАЙЛ ------------------------------------------------

//===================================  пример 1  ====================================================
// создать ТЕКСТОВЫЙ файл, содержащий несколько чисел по возрастанию, далее вводить
//  новые числа и добавлять их в файл без нарушения упорядоченности в файле
void print(FILE *ff)
{
	int i;
	if (!ff) return; //****** fopen_s может вернуть NULL(нулевой указатель), если mode r(для чтения)
	rewind(ff);
	printf("|");
	while(1)
	{  fscanf_s(ff, "%d", &i); //**************fsanf_s работает по принципу СЧИТЫВАЕМ ____X  И  смещаемся НА ОДИН СИМВОЛ ВПРАВО, где X это СКЛЕЕНОЕ ЧИСЛО ИЗ ЦИФРРРР
	                          
	   printf("%3d", i); // вывод, что находится в i
	   if(feof(ff)) break;
	}
	printf("|");
}

int main()
{
	setlocale(LC_ALL, "Russian");

	FILE *f;  //****** создание переменной ТИПА указатель на структуру FILE

	errno_t err;

	int a = 2, b = 3, c = 5, d=7, e=12;

      int ms[]={2, 3, 5, 7, 12};

	int i, j;
	fpos_t l1, l2;              // тип позиция в файле
	//err = fopen_s(&f,"aaa", "w+");  //****** fopen_s открывает файл для записи, ЕСЛИ НЕ СУЩЕСТВУЕТ,ТО W позволяет создать файл
	fopen_s(&f, "aaa", "w+");                        //****** Если существовал, то инфа сотрется, доступ к записи новой в этот же файл
	//  fprintf(f,"%3d%3d%3d%3d%3d",a,b,c,d,e); // вариант 1 - запись в файл переменных 
    for (i = 0; i<sizeof(ms)/sizeof(int); i++)  // вариант 2 - запись в файл массива чисел 
       fprintf(f, "%3d", ms[i]); //******Занос информации в файл ПЕРЕВОД ЧИСЛА В СИМВОЛЬНУЮ СТРОКУ(ПОМНИМ, ЧТО ЕСТЬ АСКИ КОДЫ ТОЛЬКО ЦИФР)
	                             //****** указатель тоже перемещается
  //	while(1)
  //	{                         // вариант 3 - запись в файл чисел введенных с клавиатуры
  //		scanf("%d", &a);       
  //		if (a == 999) break;
  //		fprintf(f, "%3d", a);
  //	}
	while (1)
	{  
		print(f);

		printf("\nвводите число : ");
		scanf_s("%d", &i);  //то число, которое мы хотим ПРАВИЛЬНО ЗАСУНУТЬ В ФАЙЛ

		if (i == 999) break;         // выход из программы

		rewind(f);	                 // установка УТПФ в начало файла и сброс
		do                           // признака конца файла
		{
			fgetpos(f, &l1);         // УТПФ на начало поля считываемого числа
			                         // ****** хранит текущее ПОЛОЖЕНИЕ значение указателя

			fscanf_s(f, "%d", &j);        // ввод очередного числа для занесения в файл 
										  //******fscans_s считывает, что находится в файле И ДАЛЬШЕ это заносит в i, а также **позиция смещается** 


			if (feof(f) || j>i)  break; // выход либо по концу файла либо найдена позиция
			                            //****** через цикл запоминаем l1
		} while (1);                    // числа большего введенного с клавиатуры

		//rewind(f);                    // УТПФ на начало файла + сброс ошибки
		if (j<i)                      // EOF и в файле нет числа > чем введенный i
		{
			fseek(f, 0, 2);           // УТПФ на конец файла (установка в конец файла)
                                      //*******fseek в случае удачи возвращает 0 иначе ненулевое значение, можно делать fseek(f,3,2);
			fprintf(f, "%3d", i);     // дозапись в конец файла
			continue;
		}
		fseek(f, -3, 2);               //******* fseek(f,-3,2) означает, что в файле f перемещаемся в конец(2-конец 0-начало,1-текущее положение), сдвигаемся на 3 байта влево 
		                               // УТПФ на последний элемент файла

		do                             // цикл сдвига всех чисел в массиве в конец на один
		{
			fgetpos(f, &l2);           // l2 позиция УТПФ числа 
			fscanf_s(f, "%d", &j);       // считывание из файла числа с позиции l2 
			//rewind(f);                 // сброс возможной ошибки (выход из файла)
			l2 += 3;                   // номер позиции следующей за l2
			fsetpos(f, &l2);           // УТПФ в новую позицию l2 (следующую)
			fprintf(f, "%3d", j);      // запись в нее считанного выше числа
	
			fseek(f, l2 - 6, 0);       // УТПФ в позицию (-3 + -3) для считывания нового числа
		} while (l1<l2 - 3);           // сдвиг в файле до позиции l1 (найдена при вводе числа i) 
		fseek(f, l2 - 3, 0);     // УТПФ на позицию "освободившегося" места в файле
		fprintf(f, "%3d", i);    // запись i на место числа с которого
	}	                         // произведен сдвиг всех чисел вниз
	print(f);
	fclose(f);
}

//----------------------------------------------------------------------------------------------------------------------
//                  int ftell(FILE*) функция, с помощью которой можно выводить ТЕКУЩЕЕ МЕСТО УКАЗАТЕЛЯ В ФАЙЛЕ
 //int l;
//l = ftell(fp);

//#include <stdio.h>
//#include <stdlib.h>
//int main(int argc, char *argv[])
//{
//	FILE *fp;
//	//	FILE *mas[5];
//	errno_t err;
//	int l;
//	int i;
//	//	fpos_t pos; /* fpos_t определен в stdio.h */
//		//pos = &l;
//		//if ((err= fopen_s(&fp,argv[1], "w+")) == NULL) {
//	fopen_s(&fp, argv[1], "w+");
//	//printf("Cannot open file.\n");
//	//exit(1);
////}
//	for (i = 0; i < 5; i++)
//		//fputc('Z', fp); /* запись 10 Z в файл */
//		fprintf(fp, "%d", i);
//	//fgetpos(fp, &pos);
//	l = ftell(fp);
//	printf("We are now at position %d in the file.", l);
//	fclose(fp);
//	return 0;
//}

/////////////---------------------------------------------------------------------////




//===================================  пример 2  ====================================================
// как и в примере выше, создать ТЕКСТОВЫЙ файл, содержащий несколько чисел 
// (одноразрядные и двухразрядные) по возрастанию, далее вводить и добавлять 
// в файл новые числа размещая их без нарушения упорядоченности в файле

//void print(FILE *ff)
//{
//	int i;
//	if (!ff) return;
//	rewind(ff);
//	printf("|");
//	while (1)
//	{
//		fscanf_s(ff, "%1000000000000000d", &i); //**** если прочитало EOF , то в i остается прошлое значение
//									//**************fsanf_s работает по принципу СЧИТЫВАЕМ ____X  И  смещаемся НА ОДИН СИМВОЛ ВПРАВО, где X это СКЛЕЕНОЕ ЧИСЛО ИЗ ЦИФРРРР
//		if (feof(ff)) break;
//		if (i<10) printf("%d  ", i);
//		else printf("%d ", i);
//		//if (feof(ff)) break;
//	}
//	printf("|");
//}
//
//int main()
//{
//	setlocale(LC_ALL, "Russian");
//	FILE *f;
//	int ms[]={2,3,5,7,12};
//	int i, j;
//	fpos_t l1, l2;              // тип позиция в файле
//
//	fopen_s(&f,"aaa", "w+");
//    for (i = 0; i<sizeof(ms)/sizeof(int); i++) 
//		if(ms[i]<10) fprintf(f, "%d  ", ms[i]);     // !!!!!   лучше везде в этом примере это заменить на
//		else fprintf(f, "%d ", ms[i]);              // !!!!!   fprintf(f, "%-3d", ms[i]);
//	while (1)
//	{
//		print(f);
//
//		printf("\nвводите число : ");
//		scanf_s("%d", &i);
//		if (i == 999) break;       // выход из программы
//		if (i >= 100) continue;    // запись в файл только одноразрядных и двухразрядных чисел
//		rewind(f);	               // установка УТПФ в начало файла и сброс
//		do                         // признака конца файла
//		{
//			fgetpos(f, &l1);       // УТПФ на начало поля считываемого числа
//			fscanf_s(f, "%d", &j);
//			//fgetpos(f, &l2);
//			if (feof(f) || j>i)  break; //выход либо по концу файла либо найдена позиция
//									  //**************fsanf_s работает по принципу СЧИТЫВАЕМ ____X  И  смещаемся НА ОДИН СИМВОЛ ВПРАВО, где X это СКЛЕЕНОЕ ЧИСЛО ИЗ ЦИФРРРР
//			l1 += 3;                  // "индекс" начала следующего числа в файле 
//			fsetpos(f, &l1);          // установка УТПФ перед следующим часлом
//		} while (1);
//		rewind(f);                    // УТПФ на начало файла + сброс ошибки
//		if (j<i)                      // EOF и в файле нет числа > чем введенный i
//		{
//			fseek(f, 0, 2);           // УТПФ на конец файла (установка в конец файла)                      
//			if (i<10) fprintf(f, "%d  ", i); // дозапись в конец файла
//			else fprintf(f, "%d ", i);
//			continue;
//		}
//		fseek(f, -3, 2);               // УТПФ на последний элемент файла
//		do                             // цикл сдвига всех чисел в массиве в конец на один
//		{
//			fgetpos(f, &l2);           // l2 позиция УТПФ числа 
//			fscanf_s(f, "%d", &j);       // считывание из файла числа с позиции l2 
//			//rewind(f);                 // сброс возможной ошибки (выход из файла)
//			l2 += 3;                   // номер позиции следующей за l2
//			fsetpos(f, &l2);           // УТПФ в новую позицию l2 (следующую)
//			if (j<10) fprintf(f, "%d  ", j);// запись в нее считанного выше числа
//			else fprintf(f, "%d ", j); //****дозапись в конец И СМЕЩЕНИЕ EOF
//			fseek(f, l2 - 6, 0);       // УТПФ в позицию (-3 + -3) для считывания нового числа
//		} while (l1<l2 - 3);           // сдвиг в файле до позиции l1 (найдена при вводе числа i) 
//		fseek(f, l2 - 3, 0);           // УТПФ на позицию "освободившегося" места в файле
//		if (i<10) fprintf(f, "%d  ", i);// запись i на место числа с которого
//		else fprintf(f, "%d ", i);      // произведен сдвиг всех чисел вниз
//	}	                         
//	print(f);
//	fclose(f);
//}






//===================================  пример 6  ====================================================
// записать в файл символьную строку, найти в файле слово max длины и удалить его из файла

//int main()
//{
//	setlocale(LC_ALL, "Russian");
//	FILE *f;
//	fpos_t n1, n2, n3;
//	long i;
//	int dl = 0;
//	char s;
//	char *st = "самое длинное слово в строке";          // вариант (например,для отладки) строка посылаемая в файл
//	//char *st;
////	st = (char *)calloc(100,1);
//	if ((fopen_s(&f,"aa", "w+")))      //***********возвращает указатель либо NULL
//	{
//		puts("файл не может быть создан");
//		return 0;
//	}
//	//rewind(stdin);
//	//gets_s(st,100);
//	
//	fprintf(f, "%s", st);                // запись исходной строки в файл
//	
//	rewind(f);                           // устанавливаем УТПФ в начало файла + сброс ошибка 
//
//	printf("\n  исходный файл  : \n");
//	while ((s = getc(f)) != EOF)         // посимвольный ввод из файла исходной строки 
//		                                 //******* getc(f) возвращает аски код символа файла, если конец, то EOF (в случае неудачи EOF ) 
//		                                 //*******  Дает символ, НО УТП СМЕЩАЕТСЯ ПРОСТОО НА ОДИН СИМВОЛ ВПРАВО, НЕ АНАЛОГ fscanf_s
//		  printf("%c", s);               // посимвольный вывод исходной строки на экран
//
//	rewind(f);                           // устанавливаем УТПФ в начало файла + сброс ошибка 
//	while (1)                                  // бесконечный цикл     
//	{
//		while (!feof(f))                       // цикл пока не конец файла
//		{                                      // пропуск пробелов в файле
//			fgetpos(f, &n1);                   // позиция считываемого символа                    
//			fscanf_s(f, "%c", &s);             //****** ТУТ ФОРМАТ СИМВООЛ, в примерах 1 и 2 там был формат целого числа
//			if (s != ' ') break;               // выход из цикла если не пробел
//		}
//
//
//
//
//		if (feof(f)) break;                    // выход из бесконечного цикла если доcтигли EOF
//
//
//
//		while (!feof(f) && (s != ' ') && (s != '\n')) // движение по буквам текущего слова в файле
//		{
//			fgetpos(f, &n2);                   // позиция последней буквой очередного слова 
//			fscanf_s(f, "%c", &s);
//		}
//		if (n2-n1>dl)                          // проверка на максимальность текущего слова
//		{                                      // запоминаем
//			dl = n2-n1;                      //      его длину
//
//			n3 = n1;                           //      его начало
//			                                   //****n3, чтобы знать откуда в дальнейшем выводить слово
//		}
//	}
//
//	i = dl;                             // рабочая переменная и с длиной слова
//	rewind(f);                          // устанавливаем УТПФ в начало файла + сброс ошибка 
//	printf("\n\n найденное слово : ");
//	fsetpos(f, &n3);                    // устанавливаем УТПФ в позицию n3 
//	while (!feof(f) && i)               // цикл вывода на экран найденного слова 
//	{                                   // пока не конец файла и длина слова !=0
//		fscanf_s(f, "%c", &s);            // чтение из файла
//		printf("%c", s);                // вывод на экран
//		i--;                            // выведена одна буква слова
//	}
//	printf("\n");
//	
//	//////вывод был выполнен длинного слова, теперь удаление из файла/////
//
//	i = dl;                             // можно присвоить любое ненулевое значение
//	n1 = n3; n2 = n1 + dl;              // позиции начала и позиция след за концом слова в файле
//	while (i)                           // цикл удаления найденного слова из файла
//	{
//		fsetpos(f, &n2);                // в позицию для чтения слимвола
//		fscanf_s(f, "%c", &s);            // чтение символа s из файла
//		if (feof(f))                    // если прочитан конец файла 
//		{
//			i = 0;                      // флаг выхода из цикла while
//			rewind(f);                  
//		}
//		fsetpos(f, &n1);                // в позицию для записи слимвола
//		fprintf(f, "%c", s);            // запись символа s в файл
//		//if (feof(f)) 
//		//	break;
//		n1++; n2++;
//	}
//	rewind(f);                          // устанавливаем УТПФ в начало файла + сброс ошибка 
//	fseek(f, 0, 2);                     // устанавливаем УТПФ в конец файла 
//	i = ftell(f);                       // позиция УТПФ в файле (i- длина файла в байтах)
//	int a = _fileno(f);
//	int b= _fileno(stdin);
//    int c= _fileno(stdout);
//    int v= _fileno(stderr);
//	_chsize(a, i -= dl);         // "усекаем" файл на длину удаленного слова
//
//	rewind(f);
//	printf("\n измененный файл : \n");
//	while ((s = getc(f)) != EOF)
//	{
//		if (s == '\r') s = '\n';
//		printf("%c", s);                // посимвольный вывод обновленного файла на экран
//	}
//    printf("\n\n");
//	/*rewind(f);
//	printf("%ld", _filelength(f));*/
//	fclose(f);
//	return 0;
//}




//int main()
//{
//	FILE *f;
//	setlocale(LC_ALL, "rus");
//
//	fopen_s(&f, "zx", "w+");
//
//	//char*str="aboba";
//	char str[100] = "aboba";
//	char sa[100] = "asd";
//	char* st;
//	st = (char*)calloc(100, 1);
//
//	fputs(str, f);   // УТПФ тоже смещается 
//	fprintf(f, "%c", '\n');
//	fputs(sa, f);   // УТПФ тоже смещается 
//	fprintf(f, "%s", "  ");
//
//
//	rewind(f);    // УТПФ в начало
//
//	fgets(st, 10, f);       //если \n то тоже в строку + УТПФ после \n
//	printf("%s", st);
//
//	fgets(st, 10, f);      //если EOF то чистая строка+ УТПФ на EOF
//	printf("%s", st);
//
//	fseek(f, -3, 1);  
//
//	fgets(st, 10, f);     // Демонстрация того, что fgets считывает с указанной позиции УТПФ до ...
//	printf("%s", st);
//
//	//printf("%ld",_filelength(f));
//	_chize(_fileno(f), 1000);
//	fclose(f);
//	
//	
//
//	return 0;
//}
void writeToFile(char* hash, char* fileName)
{
	FILE* file;
	if (!(file = fopen(fileName, "a")))
	{
		printf("\nОшибка, попробуйте еще раз");

		//goto re_write1;
	}
	fseek(file, 0, SEEK_END);
	fprintf(file, "%s", hash);
	fprintf(file, "%c", '\n');
	fclose(file);

}
void chooseTheFile(char* hash)
{
	FILE* file;
	char fileName[30];

	char symbol;
	printf("\nЗанесение акаунта в файл");
	printf("\nВведите название существующего файла, в который допишется новый аккаунт, или название нового файла: ");
	//printf("Если хотите создать новый файл, то введите 1");
	//printf("Если хотите занести аккаунт в существующий файл, то введите 2\n");

	//rewind(stdin);
	//symbol = getchar();

	//switch (symbol)
	//{
	//case'1':
	//re_write1:
	//	printf("\nВведите название файла: ");
	rewind(stdin);
	gets_s(fileName, 30);
	//	if (!(file = fopen(fileName, "w")))
	//	{
	//		printf("\nОшибка, попробуйте еще раз");
	//		goto re_write1;
	//	}
	writeToFile(hash, fileName);
	//	fclose(fileName);
	//	return;
	//	return file;

	//case'2':
	//re_write2:
	//	printf("\nВведите название  файла: ");
	//	rewind(stdin);
	//	gets_s(fileName, 30);
	//	/*if (!(file = fopen(fileName, "r+"))) 
	//	{
	//		printf("\nОшибка, попробуйте еще раз");
	//		goto re_write2;
	//	}*/
	//	writeToFile(hash, fileName);
	//	fclose(fileName);
	//	return;
	//	return file;
	//}


}

//void writeToFile(char* hash, char* fileName)
//{
//	FILE* file;
//	if (!(file = fopen(fileName, "a")))
//	{
//		printf("\nОшибка, попробуйте еще раз");
//
//	}
//	fseek(file, 0, SEEK_END);
//	fprintf(file, "%s", hash);
//	fprintf(file, "%c", '\n');
//	fclose(file);
//
//}
int main()
{
	int a;
	char d[3];
	/*scanf_s("%d", &a);
	printf("%d", a);*/

	if (gets_s(d, 3) == NULL)
	{
		printf("error");
		return 0;
	}



	return 0;
}



