//////////////////////////////////////////////////////////////////////// Пример работы с двунаправленным кольцом (списком коьцевого типа)///////////////////////////////// 
// элемент кольца имеет два указателя на элементы (справа и слева)

//#define _CRT_SECURE_NO_WARNINGS
//
//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>
//#include <conio.h>
//#include <locale.h>
//
//
//struct node
//{
//	char inf[50];  // информационное поле
//	struct node *l;       // указатель на предыдущий элемент (налево)
//	struct node *r;       // указатель на следующий элемент  (направо)
//};
//
//void show(struct node *);
//void sozd(struct node **);
//struct node *del(struct node *);
//struct node *del_any(struct node *);
//void srt(struct node *);
//struct node *srt_uk(struct node *);
//struct node *napr(char c,struct node * s);
//
//int main()
//{
//	setlocale(LC_ALL, "Russian");
//	struct node *h;              // указатель на 'начальный' элемент кольца ("точка входа")
//	h = NULL;          // кольца нет
//	char l;
//	while (1)
//	{
//		puts("вид операции: 1-создать кольцо");
//		puts("              2-вывод содержимого кольца");
//		puts("              3-удаление элемента из кольца");
//		puts("              4-удаление любого элемента из кольца");
//		puts("              5-сортировка (изменяя указатели на элементы)");
//		puts("              6-сортировка (изменяя содержимое элементов)");
//		puts("              0-выход");
//		rewind(stdin);
//		switch (getchar())
//		{
//		case '1': sozd(&h); break;
//		case '2': show(h); break;
//		case '3': h = del(h); break;
//		case '4': h = del_any(h); break;
//		case '5': if (h) h = srt_uk(h); break;
//		case '6': if (h) srt(h); break;
//		case '0': return 0;
//		}
//	}
//	return 0;
//}
//
//// функция создания/добавления в кольцо
//// добавление выполняется вправо от элемента входа в кольцо
//void sozd(struct node **h)                                 // слева направо
//{
//	struct node *s1, *s2;
//
//	if (!*h)                // кольцо еще не создано (т.е. не содержит ни одного элемента) 
//	{
//		if (!(s1 = (struct node *)malloc(sizeof(struct node))))
//		{                    // создаем первый элемент для создания кольца
//			puts("Нет свободной памяти");
//			return;
//		}
//		puts("Введите информацию в inf");
//		scanf("%s", s1->inf);
//		s1->l = s1->r = s1;  // "замыкаем" единственный элемент на себя 
//		*h = s1;             // указатель на кольцо пока с единственным эл-том
//	}
//
//	else s1 = (*h)->r;       // кольцо уже существует, s1 - указатель на право от точки входа
//	do
//	{
//		if (!(s2 = (struct node *)malloc(sizeof(struct node))))
//		{                    // создаем элемент для добавления его в кольцо
//			puts("Нет свободной памяти");
//			return;
//		}
//		puts("Введите информацию в inf");
//		scanf("%s", s2->inf);
//		// новый элемент добавляется в кольцо справа от точки входа
//		// вставляем элемент "разрывая" всязь от s1 к h
//		s1->l = s2;          // s1->l теперь указывает (налево) на новый s2 элемент
//		s2->r = s1;          // s2->r указывает (направо) на элемент s1
//							 // т.е. s2 вставился между h и s1 (и стал как бы справа от h)
//		s1 = s2;             // указатель s1 передвигаем на s2 (для добавления следующего эл-та)
//		puts("Продолжить (y/n): ");
//		rewind(stdin);
//	} while (getchar() == 'y');
//	// если цикл ввода новых эл-тов в кольцо окончен, то
//	s2->l = *h;              // устанавливаем связь налево последнего добавленного в кольцо 
//							 // эл-та s2 с точкой входа в кольцо h
//	(*h)->r = s2;            // сообщаем точке входа адрес элемента расположенного справа
//}
//
//// функция вывода содержимого кольца, обход кольца
//// выполняется по выбору либо справа налево, либо слева направо 
//void show(struct node *s)
//{
//	struct node *s1;
//	char p;
//	if (!s)
//	{
//		puts("Кольцо пустое");
//		return;
//	}
//	s1 = s;                        // указатель движения по кольцу на точку входа 
//	puts("r - по часовой, l - против часовой\n");
//	rewind(stdin);
//	switch (p = getchar())
//	{
//	case 'r': case 'R':
//	case 'l': case 'L':
//		do
//		{
//			printf("%s\n", s1->inf); // вывод содержимого элемента кольца
//			s1 = napr(p, s1);        // переход к следующему элементу кольца
//		} while (s1 != s);           // выполнен обход кольца      
//		break;
//	}
//	puts("Вывод кольца закончен");
//	return;
//}
//
//// функция удаления элемента кольца с точки входа
//// указатель на точку входа смещается вправо
//struct node *del(struct node *s)
//{
//	struct node *s1;
//	if (!s)
//	{
//		puts("Кольцо пустое"); return s;
//	}
//	s1 = s->r;           // s1 - указатель на элемент расположенный справа от точки входа 
//	if (s->r == s)       // узел в кольце один
//	{
//		free(s); return NULL;
//	}
//	else
//	{
//		s->l->r = s1;    // исключение узла s из кольца   //вместо s1 ==== s->r
//		s1->l = s->l;
//		free(s);         // удаление узла s1
//		return s1;           // новая точка входа в кольцо
//	}
//}
//
//// функция поиска и удаления элемента в СПИСКЕ имеющим
//// огранизацию двунаправленное кольцо
//struct node *del_any(struct node *s)
//{
//	struct node *s1;                       // указатель на удаляемый элемент кольца
//	char in[50];
//	if (!s)
//	{
//		puts("Кольцо пустое"); return s;
//	}
//	s1 = s;
//	puts("Введите информацию о удаляемом узле");
//	scanf("%s", in);
//	do                              // цикл просмотра содержимого кольца
//	{
//		if (strcmp(s1->inf, in)) s1 = s1->r; // не элемент для удаления
//		else                       // найден элемент кольца для удаления
//		{
//			if (s1->r == s1)       // в кольце всего один элемент 
//			{
//				free(s1); return NULL;
//			}
//			if (s == s1) s = s->r; // новая точка входа в кольцо, т.е. если удаляемый
//								   // элемент на точке входа, то смещаем ее вправо
//			s1->l->r = s1->r;      // исключение узла s1 из кольца
//			s1->r->l = s1->l;
//			free(s1);              // удаление элемента кольца s1
//			return s;
//		}
//	} while (s1 != s);               // пока не выполнен обход кольца
//	printf("Записи с информацией = %s в кольце нет \n", in);
//	return s;
//}
//
//// сортировка информации в СПИСКЕ имеющим огранизацию
//// двунаправленное кольцо, перемещением содержимого
//void srt(struct node *s)
//{
//	struct node *s1, *s2;
//	char a[50], c;
//	int i;
//	puts("направление r - по часовой, l - против часовой\n");
//	rewind(stdin);
//	c = getchar();
//	s1 = s;                           // исходный элемент списка для замены
//	do
//	{
//		strcpy(a, s1->inf);           // исходная информация для замены (из s1)
//		s2 = s1;                      // указатель "бегунок" по списку
//		do
//		{
//			s2 = napr(c, s2);         // выбор элемента для сравнения
//			if (strcmp(a, s2->inf) > 0) // найден элемент (в s2) мельший выбранного (s1)
//			{
//				strcpy(s1->inf, s2->inf); // замена содержимого s1 <--> s2
//				strcpy(s2->inf, a);
//				strcpy(a, s1->inf);
//			}
//		} while (napr(c, s2) != s);   // s2 обошло весь список
//		s1 = napr(c, s1);             // выбираем новый элемент для упорядочивания
//	} while (napr(c, s1) != s);       // s1 прошло по списку до точки входа
//}
//
//// сортировка информации в СПИСКЕ имеющим огранизацию
//// двунаправленное кольцо, изменением указателей
//struct node *srt_uk(struct node *s)
//{
//	struct node *s1, *s2, *s3;
//	int i;
//	s1 = s;                                  // указательна элемен, выбранный для упорядочивания
//	do
//	{
//		s2 = s1->r;                          // указатель "бегунок" по списку
//		s3 = s1;                             // указатель для запоминания найденного элемента "лучшего" s1
//		do
//		{
//			if (strcmp(s3->inf, s2->inf) > 0)  // сравнение текущего (s2) элемента с контрольным (s3)
//				s3 = s2;                     // если в s2 меньшее значение чем в s3 - запоминаем s2
//			s2 = s2->r;                      // движение s2 по списку вправо
//		} while (s2 != s);                   // цикл пока список не просмотрен
//		if (s3 != s1)                        // указатель s3 сместился с s1 (след-но найдено меньшее значение)
//		{                          // замена          
//			if (s == s1) s = s3;   // корректировка адреса входа в кольцо (если в нем было не меньшее значение)
//			s3->l->r = s3->r;      // исключение элемента s3 из списка
//			s3->r->l = s3->l;      // ----------
//
//			s1->l->r = s3;         // вставка элемента s3 в список перед s1 (слева)
//			s3->r = s1;            // ----------
//			s3->l = s1->l;         // ----------
//			s1->l = s3;            // ----------
//		}
//		else
//			s1 = s1->r;
//	} while (s1->r != s);
//	return s;
//}
//
//// функция выбора следующего элемента кольца (списка)
//// в зависимости от выбранного направления обхода
//struct node *napr(char c, struct node *s)
//{
//	switch (c)
//	{
//	case 'r': case 'R': return s->r;   // вправо
//	case 'l': case 'L': return s->l;   // влево
//	}
//}
//


////////////////////////////////////////////////////////////однонаправленное кольцо//////////////////////////////////////////////

//// Пример работы с однонаправленным кольцом (списком коьцевого типа) 
//// элемент кольца имеет один указатель на соседний элемент
//
//#define _CRT_SECURE_NO_WARNINGS
//
//#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>
//#include <conio.h>
//#include <locale.h>
//struct node
//{
//	char inf[50];  // информационное поле
//	struct node *nx;      // указатель на следующий элемент кольца (списка)
//};
//
//void show(struct node *);
//void sozd(struct node **);
//struct node *del(struct node *);
//struct node *del_any(struct node *);
//void srt(struct node *);
//void srt_uk(struct node **);
//
//int main()
//{
//	setlocale(LC_ALL, "Russian");
//	struct node *h;              // указатель на 'начальный' элемент кольца ("точка входа")
//	h = NULL;          // кольца нет
//	char l;
//	while (1)
//	{
//		puts("вид операции: 1-создать кольцо");
//		puts("              2-вывод содержимого кольца");
//		puts("              3-удаление элемента из кольца");
//		puts("              4-удаление любого элемента из кольца");
//		puts("              5-сортировка (изменяя указатели на элементы)");
//		puts("              6-сортировка (изменяя содержимое элементов)");
//		puts("              0-выход");
//		rewind(stdin);
//		switch (getchar())
//		{
//		case '1': sozd(&h); break;
//		case '2': show(h); break;
//		case '3': h = del(h); break;
//		case '4': h = del_any(h); break;
//		case '5': if (h) srt_uk(&h); break;
//		case '6': if (h) srt(h); break;
//		case '0': return 0;
//		}
//	}
//	return 0;
//}
//
//// функция создания/добавления в кольцо
//// добавление выполняется вправо от элемента входа в кольцо
//void sozd(struct node **h)
//{
//	struct node *s1, *s2;
//	if (!*h)                // кольцо еще создано (т.е. не содержит ни одного элемента) 
//	{
//		if (!(s1 = (struct node *)malloc(sizeof(struct node))))
//		{                    // создаем первый элемент для создания кольца
//			puts("Нет свободной памяти");
//			return;
//		}
//		puts("Введите информацию в inf");
//		scanf("%s", s1->inf);
//		s1->nx = s1;         // "замыкаем" единственный элемент на себя 
//		*h = s1;             // указатель на кольцо пока с единственным эл-том
//	}
//	else s1 = (*h)->nx;      // кольцо уже существует, s1 - указатель на след. эл-т от точки входа
//	do
//	{
//		if (!(s2 = (struct node *)malloc(sizeof(struct node))))
//		{                    // создаем элемент для добавления его в кольцо
//			puts("Нет свободной памяти");
//			return;
//		}
//		puts("Введите информацию в inf");
//		scanf("%s", s2->inf);
//		// новый элемент добавляется в кольцо справа от точки входа *h
//		// вставляем элемент между эл-тами *h и s1
//		s2->nx = s1;         // s2->nx теперь указывает на  элемент s1
//		s1 = s2;             // указатель s1 передвигаем на s2 (для добавления следующего эл-та)
//		puts("Продолжить (y/n): ");
//		rewind(stdin);
//	} while (getchar() == 'y');
//	// если цикл ввода новых эл-тов в кольцо окончен, то сообщаем
//	(*h)->nx = s2;           // точке входа адрес элемента расположенного справа 
//}
//
//// функция вывода содержимого кольца, обход кольца
//// выполняется по выбору либо справа налево, либо слева направо 
//void show(struct node *s)
//{
//	struct node *s1;
//	char p;
//	if (!s)
//	{
//		puts("Кольцо пустое");
//		return;
//	}
//	s1 = s;                        // указатель движения по кольцу на точку входа 
//	rewind(stdin);
//	do
//	{
//		printf("%s\n", s1->inf); // вывод содержимого элемента кольца
//		s1 = s1->nx;             // переход к следующему элементу кольца
//	} while (s1 != s);           // выполнен обход кольца      
//	puts("Вывод кольца закончен");
//	return;
//}
//
//// функция удаления элемента кольца с точки входа
//// указатель на точку входа смещается вправо
//struct node *del(struct node *s)
//{
//	struct node *s1;
//	if (!s)
//	{
//		puts("Кольцо пустое"); return s;
//	}
//	s1 = s->nx;           // s1 - указатель на элемент расположенный справа от точки входа 
//	if (s->nx == s)       // узел в кольце один
//	{
//		free(s); return NULL;
//	}
//	else
//	{
//		while (s1->nx != s) s1 = s1->nx; // остановка на элем. предшествующем точке входа
//		s1->nx = s->nx;    // исключение (обход) узла s (точка входа) из кольца
//		free(s);           // удаление узла s (точка входа) из кольца 
//		return s1->nx;         // новая точка входа в кольцо
//	}
//}
//
//// функция поиска и удаления элемента в СПИСКЕ имеющим
//// огранизацию однонаправленное кольцо
//struct node *del_any(struct node *s)
//{
//	struct node *s1;                       // указатель на удаляемый элемент кольца
//	struct node *s2;
//	char *in;
//	in = (char *)calloc(50, sizeof(char));
//	if (!in) return s;
//
//	if (!s)
//	{
//		puts("Кольцо пустое"); return s;
//	}
//	puts("Введите информацию о удаляемом узле");
//	fgets(in, 49, stdin);
//	s1 = s;
//	while (s1->nx != s) s1 = s1->nx; // остановка на элем. предшествующем точке входа
//	do                               // цикл просмотра содержимого кольца
//	{
//		if (strcmp(s1->nx->inf, in)) s1 = s1->nx; // s1->nx не элемент для удаления
//		else                         // найден элемент кольца для удаления
//		{
//			if (s1->nx == s1)         // в кольце всего один элемент 
//			{
//				free(s1); return NULL;
//			}
//			if (s1->nx == s) s = s->nx; // новая точка входа в кольцо, т.е. если удаляемый
//									  // элемент на точке входа, то смещаем ее вправо
//			s2 = s1->nx;              // указатель на удаляемый элемент списка
//			s1->nx = s2->nx;          // исключение узла s2 из кольца
//			free(s2);                 // удаление элемента кольца s1		
//			return s;
//		}
//	} while (s1->nx != s);               // пока не выполнен обход кольца
//	printf("Записи с информацией = %s в кольце нет \n", in);
//	return s;
//}
//
//// сортировка информации в СПИСКЕ имеющим огранизацию
//// двунаправленное кольцо, перемещением содержимого
//void srt(struct node *s)
//{
//	struct node *s1,       // указатель на элемент выбранный к сортировке
//		*s2,       // указатель "бегунок" по списку
//		*s3;       // указатель на найденный элемент к замене
//	char a[50], c;
//	int i;
//	s1 = s;                // исходный элемент списка для замены
//	do
//	{
//		s3 = s2 = s1;                 // вначале s1, s2 и s3 совпадают
//		do
//		{
//			s2 = s2->nx;              // переход по списку к сравнению следующего элемента
//			if (strcmp(s3->inf, s2->inf) > 0) // найден элемент (в s2) мельший контрольного (s3)
//				s3 = s2;               // запоминаем адрес элемента списка с меньшим значением
//
//		} while (s2->nx != s);            // s2 обошло весь список
//		if (s1 != s3)
//		{
//			strcpy(a, s1->inf);   // замена содержимого s1 <--> s3
//			strcpy(s1->inf, s3->inf);
//			strcpy(s3->inf, a);
//		}
//		s1 = s1->nx;                  // выбираем новый элемент для упорядочивания
//	} while (s1->nx != s);            // s1 прошло по списку до точки входа
//}
//
//
//// сортировка информации в СПИСКЕ имеющим огранизацию
//// двунаправленное кольцо, изменением указателей
//void srt_uk(struct node **s)
//{
//	struct node *s1, *s2,
//		*s3, *s4,
//		*s5, *s6;
//	s1 = *s;                                 // s1 указатель на точку входа, указатель на элемент,
//											 // далее используемый как исходный для упорядочивания
//	s2 = s1->nx;
//	while (s2->nx != *s) s2 = s2->nx;          // s2 указатель предшествующий s1
//	do
//	{
//		s3 = s1->nx;                             // указатель для поиска в списке элемента с меньшим значением
//		s4 = s1;                                 // указатель на элемент расположенный перед элементом s3 
//		s5 = s1;                                 // указатель на контрольный (меньший) элемент
//		do
//		{
//			if (strcmp(s5->inf, s3->inf) > 0)  // сравнение текущего (s3) элемента с контрольным (s5)
//			{
//				s5 = s3;                     // если в s3 меньшее значение чем в s5 - запоминаем s3
//				s6 = s4;                     // s6 перед s5
//			}
//			s3 = s3->nx;                     // движение s3  и s4 по списку дальше
//			s4 = s4->nx;
//		} while (s3 != *s);                  // цикл пока список не просмотрен
//		if (s5 != s1)                        // указатель s5 сместился с s1 (след-но найдено меньшее значение)
//		{                            // блок замены s1  замена          
//			if (*s == s1) *s = s5;   // корректировка адреса входа в кольцо (если в нем было не меньшее значение)
//
//			s2->nx = s5;             // s5 "становится" между s2 и s1 
//			s6->nx = s5->nx;         // "обходим" элемент s5 
//			s5->nx = s1;              // s5 указывает на s1
//			s2 = s5;                 // s2 опять перед s1;
//		}
//		else                         // для s1не найдено меньшее
//		{
//			s1 = s1->nx;             // выбор следующего элемента к сортировке
//			s2 = s2->nx;             // s2 перед ним
//		}
//		show(*s);
//	} while (s1->nx != *s);
//}












































//==================================// однонаправленная очередь//====================================


// однонаправленная очередь

#define _CRT_SECURE_NO_WARNINGS

#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <string.h>
struct zap
{
	char inf[50];            // информационное поле
	struct zap *nx;                 // адресное поле
};
void add(struct zap **, struct zap **);
void del(struct zap **, struct zap **);
void del_any(struct zap **, struct zap **, char *);
void show(struct zap *);
void sort(struct zap **);
void ReadFromFile(struct zap **, struct zap **);
void WriteToFile(struct zap **, struct zap **);

int main()
{
	setlocale(LC_ALL, "Russian");
	struct zap *h, *t;             // указатели на голову и хвост очереди
	char l, *st;
	st = (char *)malloc(10);
	h = t = NULL;

	while (1)
	{
		puts("вид операции: 1-создать очередь (добавить в очередь)");
		puts("              2-вывод содержимого очереди");
		puts("              3-удаление элемента из очереди");
		puts("              4-удаление любого элемента из очереди");
		puts("              5-сортировка очереди");
		puts("              6-запись очереди в файл");
		puts("              7-создание очереди из файла");
		puts("              0-окончить");
		rewind(stdin);
		switch (getchar())
		{
		case '1': add(&h, &t); break;        // добавление в хвост очереди
		case '2': show(h); break;            // просмотр с головы очереди
		case '3': if (h) del(&h, &t); break; // удаление с головы очереди
		case '4': if (h)                     // удаление с любого места в очереди (списка)
		{
			rewind(stdin);
			puts("Введите информацию для удаления ");
			gets(st);
			del_any(&h, &t, st);
		} break;
		case '5': if (h) sort(&h); break;    // сортировка очереди (списка)
		case '6': WriteToFile(&h, &t); break;
		case '7': ReadFromFile(&h, &t); break;
		case '0': return 0;
		default: printf("Ошибка, повторите \n");
		}
	}
}

// функция создания очереди (и добавления) 
// новые элементы добавляются в хвост (t) очереди
void add(struct zap **h, struct zap **t)
{
	struct zap *n;
	puts("Создание очереди \n");
	do
	{
		if (!(n = (struct zap *)calloc(1, sizeof(struct zap))))
		{
			puts("Нет свободной памяти");
			return;
		}
		puts("Введите информацию в inf");
		scanf("%s", n->inf);
		//gets(n->inf);
		if (!*h)                         // очередь еще не создана
			*t = *h = n;                 // устанавливаем оба указателя (голова и хвост)
										 // на единственный элемент очереди
		else                             // очередь уже создана
		{
			(*t)->nx = n;                // добавляем очередной элемент в хвост очереди 
			*t = n;                      // передвигаем указатель на хвост
		}
		puts("Продолжить (y/n): ");
		rewind(stdin);
	} while (getchar() == 'y');
}

// функция вывода содержимого очереди
// вывод содержимого очереди от h до t
void show(struct zap *h)
{
	puts("Вывод содержимого очереди \n");
	if (!h)
	{
		puts("Очередь пуста");
		return;
	}
	do
	{
		printf("%s\n", h->inf);
		h = h->nx;        // перемещение указателя h на следующий эл-т
	} while (h);          // условие - пока не вышли за хвост очереди
	return;
}

// функция удаления элемента очереди
// удаляется элемент расположенный в голове (h) очереди
void del(struct zap **h, struct zap **t)
{
	/*if (*t == NULL)
	{
		printf("\nНечего удалять");
		return;
	}*/
	struct zap *p;
	if (*t == *h)                    // в очереди только один элемент
	{
		free(*h);
		*t = *h = NULL;           // очередь пуста
		return;
	}
	p = (*h)->nx;
	free(*h);                        // удаление первого элемента из очереди
	*h = p;
}

// функция удаления любого элемента СПИСКА организованного
// по типу однонаправленной очереди
void del_any(struct zap **h, struct zap **t, char *st)
{
	struct zap *p, *pr;                    // указатели: на анализируемый элемент и 
									// предыдущий ему элемент очереди (списка)
	if (*t == *h &&                 // если в очереди (списке) только один элемент
		(!strcmp((*h)->inf, st) || *st == '\0'))
	{
		free(*t);                   // удаление единственного элемента очереди (списка)
		*t = *h = NULL;          // очередь (список) пуста
		return;
	}
	while (*h && !strcmp((*h)->inf, st)) // удаление всех элементов st
										 // с головы очереди (списка)
	{
		p = *h;               // сохраняем адрес удаляемого элемента
		*h = (*h)->nx;        // премещение указателя на голову очереди (списка)
							  // на следующий элемент
		free(p);              // удаление элемента          

	}
	p = (*h)->nx;             // следующий за элементом головы очереди (списка)
	pr = (*h);                // элемент очереди (списка) перед ним	
	while (p)
	{
		if (!strcmp(p->inf, st)) // удаление всех элементов st
								 // с головы очереди (списка)
		{
			pr->nx = p->nx;  // исключение из очереди (списка) удаляемого элемента
			free(p);         // удаление из очереди          
			p = pr->nx;      // премещение головы на следующий элемент
		}
		else
		{
			p = p->nx;       // переход к новому элементу очереди (списка) 
			pr = pr->nx;
		}
	}
	p = *h;
	while (p->nx) p = p->nx; // проход по новой очереди до конца
	*t = p;                  // коррекция адреса хвоста очереди (списка)
}

// функция сортировки содержимого СПИСКА организованного
// по типу однонаправленной очереди изменением указателей
void sort(struct zap **h)
{
	struct zap *s1, *s2, *s3, *s4, *hh = NULL;
	s1 = s3 = *h;                             // ссылка на голову очереди (списка)
	s4 = (struct zap *)calloc(1, sizeof(struct zap));
	for (; s1->nx; s1 = s1->nx)               // выбор исходного элемента очереди (списка)
	{
		for (s2 = s1->nx; s2; s3 = s3->nx, s2 = s2->nx) // перебор последующих за S1
		{
			if (s2 == s1->nx) s3 = s1;        // S3-элемент расположенный перед S2
			if (strcmp(s1->inf, s2->inf) > 0)   // найдено новое меньшее значение
			{
				s3->nx = s2->nx;
				s2->nx = s1;                  // элемент с min становится перед S1
				s4->nx = s2;                  // S4- элемент расположенный перед S1
				s1 = s2;	                  // новый адрес S1- (после замены S1<->S2)
			}
		}
		if (!hh)
		{
			hh = s1;       // модификация текущего указателя на голову очереди (списка)
			free(s4);
		}
		s4 = s1;
	}
	*h = hh;              // возврат возможно измененного указателя на голову
	puts("Сортировка выполнена");
}

void ReadFromFile(struct zap **h, struct zap **t)
{
	struct zap *n;
	char name[30];
	FILE *f;
	puts("Создание очереди из файла\n");
	if (*h || *t) return;
	puts(" имя файла : ");
	scanf("%s", name);
	if (!(f = fopen(name, "r"))) return;
	do
	{
		if (!(n = (struct zap *)calloc(1, sizeof(struct zap))))
		{
			puts("Нет свободной памяти");
			return;
		}

		fscanf(f, "%s", n->inf);
		if (feof(f))
		{
			free(n);
			return;
		}
		if (!*h)                         // очередь еще не создана
			*t = *h = n;                 // устанавливаем оба указателя (голова и хвост)
										 // на единственный элемент очереди
		else                             // очередь уже создана
		{
			(*t)->nx = n;                // добавляем очередной элемент в хвост очереди 
			*t = n;                      // передвигаем указатель на хвост
		}
	} while (1);
	fclose(f);
}

void WriteToFile(struct zap **h, struct zap **t)
{
	struct zap *n;
	char name[30];
	FILE *f;
	puts("Запись очереди в файл\n");
	if (!*h || !*t) return;
	puts(" имя файла : ");
	scanf("%s", name);
	if (!(f = fopen(name, "w"))) return;
	do
	{
		fprintf(f, "%s\n", (*h)->inf);
		n = *h;                 // 
		*h = (*h)->nx;
		free(n);
	} while (*h);
	*t = *h;
	fclose(f);
}




//==================================//Двунаправленная очередь//====================================

// двунаправленная очередь
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <string.h>
struct zap
{
	char inf[50];      // информауционное поле
	zap *pr;           // указатель на предыд. эл-т
	zap *nx;           // указатель на следующ. эл-т
};
void add(zap **, zap **);
void insert(zap **);
void del_any(zap **, zap **, char *);
void see(zap *, int);
void sort(zap **, zap **);

int main()
{
	setlocale(LC_ALL, "Russian");
	zap *t, *h;                       // указатели на хвост и голову очереди
	char l, *st;
	st = (char *)malloc(10);
	t = h = nullptr;
	while (1)
	{
		puts("вид операции: 1-создать очередь (добавить в очередь)");
		puts("              2-вывод содержимого очереди");
		puts("              3-вставка нового элемента в очередь");
		puts("              4-удаление любого элемента из очереди");
		puts("              5-сортировка очереди");
		puts("              0-окончить");
		fflush(stdin);
		switch (getch())
		{
		case '1': add(&t, &h); break; // создание(/добавление) очереди
		case '2':
			puts("0-просмотр с хвоста\n1- просмотр с головы");
			l = getch();
			if (l == '0') see(t, 0);  // просмотр с хвоста очереди
			else see(h, 1);           // просмотр с головы очереди
			break;
		case '3': if (t)              // очередь не пуста
			insert(&t);               // добавление от хвоста очереди
			break;
		case '4': if (t)
		{
			gets(st);
			del_any(&t, &h, st);
		} break;
		case '5': if (t) sort(&t, &h); break;
		case '0': return 0;
		default: printf("Ошибка, повторите \n");
		}
	}
}

// функция создания очереди  и добавления (ТОЛЬКО) в хвост очереди
void add(zap **pt, zap **ph)
{
	zap *n;
	puts("Создание очереди \n");
	do
	{
		if (!(n = (zap *)calloc(1, sizeof(zap))))
		{
			puts("Нет свободной памяти");
			return;
		}
		puts("Введите информацию в inf");
		scanf("%s", n->inf);
		if (!*pt || !*ph)   // очередь еще не создана
		{
			*pt = n;          // указатель на хвост очереди
			*ph = n;          // указатель на голову очереди
		}
		else
		{
			n->nx = *pt;     // указатель на элемент (хвост) очереди
			(*pt)->pr = n;   // хвост указывает на новый элемент
			*pt = n;         // передвигаем указатель хвоста на новый элемент
		}
		puts("Продолжить (y/n): ");
		fflush(stdin);
	} while (getch() == 'y');
}

// функция вывода содержимого очереди
// вывод начинать с хвоста (i==0) или головы (i==1)
void see(zap *p, int i)
{
	puts("Вывод содержимого очереди \n");
	if (!p)
	{
		puts("Очередь пуста");
		return;
	}
	do
	{
		printf("%s\n", p->inf);
		if (!i) p = p->nx;  // движение к голове очереди
		else p = p->pr;    // движение к хвосту очереди
	} while (p);
	return;
}

// функция добавления элемента в очередь  (до головы очереди)
// добавление работает правильно только если очередь упорядочена
// с хвоста по возрастанию  [ (хвост) 1 2 5 7 9 (голова)  вставить 4 ]
void insert(zap **ptr)
{
	zap *p = *ptr, *n;
	char s[50];
	puts("Введите информацию в для добавления\n");
	fflush(stdin);
	gets(s);
	while (p && strcmp(p->inf, s) < 0) p = p->nx;  // пока не найдено большее чем вводимое
	if (!(n = (zap *)calloc(1, sizeof(zap))))    // создание нового элемента
	{
		puts("Нет свободной памяти");
		return;
	}
	strcpy(n->inf, s);       // копирует строку s в поле n->inf
	p->pr->nx = n;           // предыдущий эл-т очереди указывает на вводимый эл-т (n)
	n->nx = p;               // новый элемент указывает на последующ. элемент очереди p
	n->pr = p->pr;	         // новый элемент указывает на предыдующ. элемент очереди p
	p->pr = n;               // последующий эл-т очереди указывает на вводимый эл-т
}

// функция удаления любого одного элемента очереди
// pt- указатель на хвост  ph- на голову очереди
void del_any(zap **pt, zap **ph, char *st)
{
	zap *p = *pt;                  // рабочий указатель на голову очереди
	if (!*pt || !*ph)              // проверка на пустоту очереди
	{
		puts("Очередь пуста");
		return;
	}
	if (p->nx == NULL &&           // в очереди только один элемент
		(!strcmp(p->inf, st) || *st == '\0'))
	{
		free(p);                   // удаление этого элемента очереди
		*pt = *ph = nullptr;       // очередь пуста
		return;
	}
	while (p && strcmp(p->inf, st)) p = p->nx; // движение по очереди либо
								   // до хвоста, либо до искомого элемента

	if (!strcmp(p->inf, st))       // найден элемент со строкой  st
	{
		if (p == *pt)              // удаляемая вершина - хвост очереди
		{
			*pt = (*pt)->nx;       // новый указатель на хвост очереди
			(*pt)->pr = nullptr;   // удаление связи с исключаемым из очереди
		}
		else if (p == *ph)         // удаляемая вершина - голова очереди
		{
			*ph = (*ph)->pr;    // новый указатель на голову очереди
			(*ph)->nx = nullptr;// удаление связи с исключаемым из очереди
		}
		else
		{
			p->pr->nx = p->nx;  // обходим элемент  pr (исключаемый из очереди)
			p->nx->pr = p->pr;
		}
		free(p);                   // удаление искомого эл-та из очереди
	}
}

// функция сортировки содержимого СПИСКА организованного
// по типу двунаправленной очереди изменением указателей
void sort(zap **t, zap **h)
{
	zap *s1, *s2, *s3;

	for (s2 = *h; s2; s2 = s2->pr)           // цикл выбора эл-та s2 с головы списка
		for (s1 = *t; s1->nx; s1 = s1->nx)       // цикл выбора эл-та s1 с хвоста списка
		{
			if (strcmp(s1->nx->inf, s1->inf) > 0)  // найдены 2 эл-та списка которые надо
			{                                    // поменять местами
				s3 = s1->nx;                     // s3- вершина следующая за s1
				if (!s1->pr) *t = s1->nx;        // модификация хвоста списка
				s1->nx = s1->nx->nx;             // s1-nx указывает через вершину
				if (s1->nx) s1->nx->pr = s1;     // s1->nx выше был модифицирован
				else s2 = *h = s1;               // s1->nx==nullptr -коррекция головы
				s3->pr = s1->pr;
				s3->nx = s1;
				if (s3->pr) s3->pr->nx = s3;
				s1->pr = s3;
				s1 = s1->pr;                     // откат для s1=s1->nx в цикле for
			}
		}
	puts("Сортировка выполнена");
}
