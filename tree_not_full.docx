// операции с бинарным деревом

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <dos.h>
#include <Windows.h>
#include <locale.h>
#define N 20          // размерность информационного поля

struct tree
{
	char *inf;         // информационное поле
	int n;             // число встреч инф. поля в бинарном дереве
	struct tree *L, *R;       // указатель на левое и правое поддерево
	bool Lflg, Rflg;   // признак: true - обычная связь, false - прошитая связь
};

void show_1(tree *);
void show_2(tree *);
void show_3(tree *);
void print(tree *, int = 0);
tree *creat1(tree *, char *);
tree *creat2(tree *, char *);
tree *erase(tree *);
void rigch_insertion(tree *);

int main()
{
	struct tree *dr = nullptr;        // адрес корня бинарного дерева
	char * st;
	setlocale(LC_ALL, "Russian");
	while (1)
	{
		puts("\nвид операции: 1-создать дерево не рекурсивно");
		puts("              2-создать дерево рекурсивно");
		puts("              3-рекурсивный вывод содержимого дерева");
		puts("              4-нерукурсивный вывод содержимого дерева");
		puts("              5-псевдографический вывод содержимого дерева");
		puts("              6-удаление любого элемента из дерева");
		puts("              7-прошивка бинарного дерева");
		puts("              8-нерекурсивный вывод прошитого дерева");
		puts("              9-выход");
		rewind(stdin);
		switch (getchar())
		{
		case '1':
			puts("Введите информацию о узле дерева и <Enter>");
			puts("по окончании ввода просто нажмите еще раз <Enter> без ввода информации");
			st = (char *)malloc(N);
			while (1)
			{
				rewind(stdin);
				gets_s(st, N);
				if (*st)
					dr = creat1(dr, st);
				else break;
			}
			free(st);
			break;
		case '2':
			puts("Введите информацию о узле дерева и <Enter>");
			puts("по окончании ввода просто нажмите еще раз <Enter> без ввода информации");
			st = (char*)malloc(N);
			while (1)
			{
				rewind(stdin);
				gets_s(st,N);
				if (*st) dr = creat2(dr, st);
				else break;
			}
			free(st);
			break;
		case '3': show_1(dr); getchar(); break;
		case '4': show_2(dr); getchar(); break;
		case '5': print(dr); getchar(); break;
		case '6': erase(dr); break;
		case '7': rigch_insertion(dr); break;
		case '8': show_3(dr); getchar(); break;
		case '9': return 0;
		default: puts("ошибка в выборе варианта");
		}
	}
	puts("\n");
	return 0;
}

// нерекурсивное создание бинарного дерева
// новый элемент (узел, лист) добавляется в конец ветви дерева 
tree* creat1(tree *dr, char *st)
{
	tree *dr1, *dr2;
	dr1 = (tree *)malloc(sizeof(tree));  // создание нового элемента(узла) добавляемого в дерево
	dr1->inf = (char *)malloc(strlen(st) + 1);
	strcpy(dr1->inf, st);                // ввод информации в этот новый элемент
	dr1->n = 0;
	dr1->L = dr1->R = nullptr;
	dr1->Lflg = dr1->Rflg = true;
	if (!dr) return dr1;       // если дерево пустое (dr==nullptr если в дерево еще не было ввода инф.)
	else                      // иначе поиск места в дереве куда добавляется новый элемент
	{
		dr2 = dr;
		while (dr2)            // dr2-указатель "пробегает" по дереву до искомого узла или до конца ветви
		{
			if (strcmp(dr1->inf, dr2->inf) == 0)  // в дереве найдена искомая информация
			{                                    // т.е. узел с такой информацией уже в дереве есть
				dr2->n++;                        // увеличивается счетчик в найденном узле,       
				free(dr1->inf); free(dr1); break;// а dr1 не добавляется как новый элемент 
			}
			else              // в узле dr2 дерева информациея не совпадает с искомой
				if (strcmp(dr1->inf, dr2->inf) < 0)  // dr1->inf меньше dr2->inf  
					if (dr2->L == nullptr)           // из вершины dr2 нет движения влево 
					{
						dr2->L = dr1;                 // вставка узла dr1 в дерево
						dr2 = nullptr;  // для выхода из цикла while
					}
					else dr2 = dr2->L;              // переход к следующей вершине дерева слева от dr2
				else                              // иначе: dr1->inf больше dr2->inf 
					if (dr2->R == nullptr)           // из вершины dr2 нет движения вправо 
					{
						dr2->R = dr1;                 // вставка узла dr1 в дерево
						dr2 = nullptr; // для выхода из цикла while
					}
					else dr2 = dr2->R;              // переход к следующей вершине дерева справа от dr2
		}
	}
	return dr;
}

//  рекурсивное создание бинарного дерева //ПО ОДНОМУ ЭЛЕМЕНТУУУУ1111
tree* creat2(tree *dr, char* st)
{                //1) просто для создания и выхода 2) доход до листа и подключение и выход
	if (!dr)     // это условие, что при движении по дереву выход за лист
	{            // т.е.  st не найдено в дереве
		dr = (tree *)malloc(sizeof(tree));   // создание нового элемента(узла), вводимого в дерево
		dr->inf = (char *)malloc(strlen(st) + 1);
		strcpy(dr->inf, st);                 // ввод информации в этот новый элемент 
		dr->n = 0;                           // число повторов ввода информации в узел дерева
		dr->L = dr->R = nullptr;             // это новый лист
	}
	//после верхнего if перепрыг на return dr;
	else if (strcmp(st, dr->inf) == 0) dr->n++;          // информация уже есть в дереве
	else if (strcmp(st, dr->inf) < 0) dr->L = creat2(dr->L, st); // иначе движение влево
	else dr->R = creat2(dr->R, st);                       // движение вправо
	return dr;
}

// рекурсивный вывод содержимого бинарного дерева
void show_1(tree *dr)
{
	if (dr)
		// для вывода информации удалите комментарий с одной
		// из инструкций printf  содержащихся ниже
	{  //  printf("узел содержит :   %s , число встреч %d\n",dr->inf,dr->n); //(1) //прямой обход(1)
		if (dr->L) show_1(dr->L);     // вывод левой ветви дерева
		printf("узел содержит :   %s , число встреч %d\n", dr->inf, dr->n);  //(2)
		if (dr->R) show_1(dr->R);     // вывод правой ветви дерева
		//printf("узел содержит :   %s , число встреч %d\n", dr->inf, dr->n);//(3) //симметричный обход
		
	}
}

// нерекурсивный вывод содержимого бинарного дерева
// используя стек для занесения адресов узлов дерева
void show_2(tree *dr1)
{
	struct stack    // стек узлов дерева через которые осуществляется движение по ветви 
	{
		tree *d;            // узел дерева  
		stack *s;
	} *st, *st1 = nullptr;

	if (!dr1)
	 printf("бинарное дерево пустое\n"); return; 
	
	int pr = 1;            // 1 - признак движения влево по ветви дерева
											// в стек заносится элемент содержащий указа-
	st = (stack *)calloc(1, sizeof(stack)); // тель на корень дерева для прохода по
	st->d = dr1;                            // левому и правому поддеревьям
	st->s = st1;                            // указатель на предыдущий эл-т стека 
	printf("узел содержит :   %s , число встреч %d  ", dr1->inf, dr1->n);
	printf(dr1->Lflg ? "  ( true, " : "  ( false ");
	printf(dr1->Rflg ? "true )\n" : "false )\n");
	while (st || dr1->R)  // пока стек не пустой и есть движение вправо по дереву
	{
		do  // цикл - пока не лист дерева
		{
			if (pr && dr1->L) dr1 = dr1->L;  // переход на узел слева                    
			else if (dr1->R) dr1 = dr1->R;   // переход на узел cправа
			pr = 1;                   // сброс принудительного движения вправо
			if (dr1->L && dr1->R)      // узел с 2 связями (вниз по дереву)
			{
				st1 = st;               // запоминаем вершину стека
				st = (stack *)calloc(1, sizeof(stack)); // новый эл-т стека
				st->d = dr1;            // указатель на найденый узел дерева
				st->s = st1;            // указатель из вершины стека на предыдущий 
			}
			printf("узел содержит :   %s , число встреч %d  ", dr1->inf, dr1->n);
			printf(dr1->Lflg ? "  ( true, " : "  ( false ");
			printf(dr1->Rflg ? "true )\n" : "false )\n");
		} while (dr1->L || dr1->R);

		//сюда 3 вида выводов

		if (st)                      // стек не пустой
		{                            // с вершины стека считываем узел(ветвления) дерева 
			dr1 = st->d;             // для возврата на этот узел ветвления в дереве
			st1 = st->s;             // указатель вниз на следующий элемент стека
			free(st);                // удаление из стека указателя на выбранный узел
		}
		st = st1;                    // запоминаем новую вершину стека
		if (dr1->L && dr1->R) pr = 0;   // это узел ветвления, устанавливаем признак принудительного 
		else break;                     // перехода на узел расположенный справа от dr1, т.к.
										// dr1->inf уже выведен при проходе слева
	}
}

//  псевдографический вывод содержимого бинарного дерева
void print(tree* dr, int level)
{
	if (dr) print(dr->R, level + 1); //
	for (int n = 0; n < level; ++n) printf("   ");
	if (dr) printf("%s (%d)\n", dr->inf, dr->n);
	else printf("@\n");
	if (dr) print(dr->L, level + 1); //
}

// функция удаления узла бинарного дерева
tree* erase(tree *dr)
{
	tree *dr1, *dr2, *dr3;
	char *st;                 // строка для анализа информации
	int k;                    // результат сравнения двух строк
	int ind;
	if (!dr)
	{
		puts("бинарное дерево пустое\n");
		return NULL;
	}
	puts("Введите информацию в для поиска удаляемого узла");
	st = (char *)malloc(sizeof(char)*N);
	fflush(stdin);
	gets_s(st,N);                 // строка для поиска узла в дереве
	if (!*st) return NULL;    // выход в функцию  main при вводе пустой строки
	dr2 = dr1 = dr;           // dr1 и dr2 устанавливаются на корень дерева
	ind = 0;                  // 1 - признак выхода из цикла поиска
	do                        // цикл поиска удаляемого из дерева узла dr1
	{
		if (!(k = strcmp(st, dr1->inf)))
			ind = 1;          // удаляемый узел со строкой st найден
		if (k < 0)              // введ. строка  <  строки в анализируемом узле
		{
			if (dr1->L)       // движение налево из узла dr1 существует
			{
				dr2 = dr1;    // запоминаем текущий узел
				dr1 = dr1->L; // считываем новый левый узел дерева
			}
			else ind = 1;     // выход из цикла do ... while при ненахождении информации в дереве
		}
		if (k > 0)          // введ. строка  >  строки в анализируемом узле
		{
			if (dr1->R)
			{
				dr2 = dr1;      // запоминаем текущий узел
				dr1 = dr1->R;   // считываем новый правый узел дерева
			}
			else ind = 1;     // выход из цикла do ... while при ненахождении информации в дереве
		}
	} while (!ind);
	free(st);
	if (k)
	{
		puts("Требуемый узел не найден \n");
		getchar();
		return dr;
	}
	else
	{
		k = strcmp(dr1->inf, dr2->inf);
		dr3 = dr1;             // запоминаем удаляемую вершину дерева
		if (k < 0)               // удаляемая вершина < предыдущей
		{
			if (dr1->R)           // у вершины dr1 есть ветвь вправо
			{
				dr3 = dr1->R;     // переход на вершину вправо от удаляемой и далее
				while (dr3->L) dr3 = dr3->L; // поиск вершины с nullptr влево
				dr2->L = dr1->R;  // обход удаляемой вершины dr1
				dr3->L = dr1->L;
			}
			else dr2->L = dr1->L; // просто удаление вершины dr1, не имеющей правой связи
		}
		else                  // удаляемая вершина > предыдущей
		{
			if (dr1->L)          // у вершины dr1 есть ветвь вправо
			{
				dr3 = dr1->L;        // переход на вершину влево от удаляемой и далее
				while (dr3->R) dr3 = dr3->R;// поиск вершины с nullptr вправо
				dr2->R = dr1->L;    // обход удаляемой вершины dr1
				dr3->R = dr1->R;
			}
			else dr2->R = dr1->R;  // просто удаление вершины dr1, не имеющей левой связи
		}
		free(dr1->inf); free(dr1);
	}
}

// функция симметричной правостороней "прошивки" бинарного дерева
void rigch_insertion(tree *dr)
{
	tree *dr1 = dr;
	struct steak
	{
		int n;                              // число проходов через вершину
		tree *d;                            // указатель на вершину дерева
		steak *s;
	} *st, *st1 = nullptr, *st2;
	if (!dr1) { printf("бинарное дерево пустое\n"); return; }
	int pr = 1;                             // признак движения по левой ветви дерева
											// в стек заносится элемент содержащий 
	st = (steak *)calloc(1, sizeof(steak)); // указатель на корень дерева для прохода
	st->n++;
	st->d = dr1;                            // по левому и правому поддеревьям
	st->s = st1;                            // указатель на стек вниз
	while (st || dr1->R)
	{
		if (!st) return;                    // стек вершин ветвления пустой - дерево "прошито"
		do
		{
			if (pr && dr1->L) dr1 = dr1->L; // переход на узел слева
			else if (dr1->R) dr1 = dr1->R;  // переход на узел cправа
			pr = 1;                         // сброс принудительного движения вправо
											// все вершины на анализируемом пути заносятся в стек
			if (dr1->L || dr1->R)
			{
				st1 = st;
				st = (steak *)calloc(1, sizeof(steak));
				st->n++;
				st->d = dr1;                    // указатель на найденый узел
				st->s = st1;                    // указатель на стек вниз
			}
			if (!dr1->R)             // нет перехода на вершину справа следовательно "прошиваем" этот переход
			{ // dr1->Rflg=false;    // признак перехода вверх (возврата)
				st2 = st;
				while (st2->s && strcmp(st2->d->inf, dr1->inf) <= 0) // цикл по стеку соответствующий 
					st2 = st2->s;    // подъему по дереву вверх пока не встретится вершина большая чем 
									 // анализируемая или не просмотрим весь стек (крайняя правая вершина) 
				if (!st2) st2 = st;  // для "прошивки" крайней правой вершины дерева в стеке нет вершин 
									 // с большим значением, следовательно из стека выбирается вершина 
				dr1->R = st2->d;     // записываем указатель на вершину с большим значением (или на корень)
				dr1->Rflg = false;   // устанавливается признак "прошитой" вершины дерева
				printf("\n вершина  %s (", dr1->inf);
				printf(dr1->Lflg ? "true, " : "false ");
				printf(dr1->Rflg ? "true, " : "false ");
				printf(" ) ---->  %s", st2->d->inf);
			}
		} while (dr1->L || (dr1->R && dr1->Rflg));
		while (st && (pr || st->d->Rflg == false))// в стеке указатель на узел или 
												  // на уже "прошитую" вершину дерева
		{
			dr1 = st->d;                          // возврат на узел ветвления
			if (dr1->R && dr1->Rflg)
			{
				pr = 0;    // признак принудительного перехода на узел расположенный справа от dr1
						   // при этом dr1 не "прошитая" вершина дерева 
				st->n++;   // вершина дерева просматривается еще по одному направлению
			}
			st1 = st;
			if (st->n > 2 || (pr || st->d->Rflg == false))
			{
				st1 = st->s;         // на вершине стека - адрес узла выше удаляемого из стека
				free(st);            // удаление из стека указателя на узел
				st = st1;
				pr = 1;              // сброс принудительного движения вправо
			}
		}
		st = st1;
	}
}

//==============================================

// нерекурсивный вывод содержимого прошитого справа 
// бинарного дерева без использования стека вершин

//  ДОРАБОТАТЬ !!!!!!!

void show_3(tree *dr)
{
	tree *dr1 = dr;
	if (!dr1) { printf("бинарное дерево пустое\n"); return; }
	int pr = 1;            // 1 - признак движения влево по ветви дерева
	do  // цикл - пока не лист дерева
	{
		if (pr && dr1->L) dr1 = dr1->L;  // переход на узел слева
		else
		{
			if (!dr1->Rflg) pr = 0;
			else pr = 1;
			if (dr1->R) dr1 = dr1->R;   // переход на узел cправа
		}
		printf("узел содержит :   %s , число встреч %d  ", dr1->inf, dr1->n);
		printf(dr1->Lflg ? "  ( true, " : "  ( false ");
		printf(dr1->Rflg ? "true )\n" : "false )\n");
	} while (dr1->L || dr1->R);
}
